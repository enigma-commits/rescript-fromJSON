// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Js_dict = require("rescript/lib/js/js_dict.js");
var Belt_Array = require("rescript/lib/js/belt_Array.js");
var Caml_array = require("rescript/lib/js/caml_array.js");
var Belt_Option = require("rescript/lib/js/belt_Option.js");

function replaceFirstLetterLower(inputString) {
  if (inputString.length > 0) {
    return inputString.charAt(0).toLowerCase() + inputString.slice(1);
  } else {
    return inputString;
  }
}

function replaceFirstLetterUpper(inputString) {
  if (inputString.length > 0) {
    return inputString.charAt(0).toUpperCase() + inputString.slice(1);
  } else {
    return inputString;
  }
}

function getRecordType(_str, _type_, allfiles) {
  while(true) {
    var type_ = _type_;
    var str = _str;
    var re = new RegExp("(type\\s" + type_ + "+)\\s[=]\n*\\s+({([a-zA-Z0-9_ :.,\n*\\s<>]+)})+");
    var vareintRe = new RegExp("type\\s+" + type_ + "+\\s*=\\s*(\|[^|]+)");
    var vareintTypeRe = new RegExp("type\\s+" + type_ + "\\s*=\\s*[\\|?\\s]\\s*([A-Z][a-zA-Z0-9()_\\s\|]+)\n");
    var match = str.match(re);
    if (match !== null) {
      return [
              /* Normal */1,
              Caml_array.get(Belt_Array.keepMap(match, (function (x) {
                          return x;
                        })), 2)
            ];
    }
    var match$1 = str.match(vareintRe);
    if (match$1 !== null) {
      var match$2 = str.match(vareintTypeRe);
      if (match$2 !== null) {
        return [
                /* Varient */0,
                Caml_array.get(Belt_Array.keepMap(match$2, (function (x) {
                            return x;
                          })), 1)
              ];
      }
      var match$3 = type_.split(".");
      if (match$3.length !== 2) {
        return [
                /* Varient */0,
                "// Unable to find type of " + type_
              ];
      }
      var module_ = match$3[0];
      var type1_ = match$3[1];
      var file = Js_dict.get(allfiles, module_);
      if (file === undefined) {
        return [
                /* Varient */0,
                "// Unable to find type of " + type1_
              ];
      }
      _type_ = type1_;
      _str = file;
      continue ;
    }
    var match$4 = type_.split(".");
    if (match$4.length !== 2) {
      return [
              /* Normal */1,
              "// Unable to find type of " + type_
            ];
    }
    var module_$1 = match$4[0];
    var type1_$1 = match$4[1];
    var file$1 = Js_dict.get(allfiles, module_$1);
    if (file$1 === undefined) {
      return [
              /* Normal */1,
              "// Unable to find type of " + type1_$1
            ];
    }
    _type_ = type1_$1;
    _str = file$1;
    continue ;
  };
}

function defaultUserTypedValue(str) {
  if (str.startsWith("option")) {
    return "None";
  } else if (str.startsWith("array")) {
    return "[]";
  } else if (str.startsWith("Js.Nullable")) {
    return "Js.Json.null";
  } else {
    return "default" + replaceFirstLetterUpper(str) + "";
  }
}

function defaultValueMapper(str) {
  switch (str) {
    case "Js.Json.t" :
        return "Js.Dict.empty()->Js.Json.object_";
    case "bool" :
        return "false";
    case "float" :
        return "0.0";
    case "int" :
        return "0";
    case "string" :
        return "\"\"";
    default:
      return defaultUserTypedValue(str);
  }
}

function filterTypeName(str) {
  return str.replace(/array<([a-zA-Z\.<>.]+)>/g, "$1").replace(/option<([a-zA-Z\.<>.]+)>/g, "$1");
}

function getDefaultValue(str, type_, allfiles) {
  var type_$1 = filterTypeName(type_);
  var match = getRecordType(str, type_$1, allfiles);
  var blockScopeTypes = match[1];
  var convertedBlock = blockScopeTypes.replace(/([A-Za-z0-9_^]+)+\s*[:]\s+([a-zA-Z0-9_.<>]+)/g, (function (param, first, second, param$1, param$2) {
          var valueMapper = defaultValueMapper(second);
          return "" + first + " : " + valueMapper + "";
        }));
  if (match[0]) {
    return "let default" + replaceFirstLetterUpper(type_$1) + " = " + convertedBlock + "\n\n";
  }
  var $$default = Belt_Array.get(blockScopeTypes.split("|"), 1);
  if ($$default === undefined) {
    return "";
  }
  var regex = /^([a-zA-Z_]\w*)\(([a-zA-Z_]\w*)\)$/;
  var match$p = regex.exec($$default.trim());
  if (match$p === null) {
    return "let default" + replaceFirstLetterUpper(type_$1) + " = " + $$default + "\n";
  }
  var enumName = Caml_array.get(match$p, 1);
  var enumType = Caml_array.get(match$p, 2);
  return "let default" + replaceFirstLetterUpper(type_$1) + " = " + enumName + "(default" + replaceFirstLetterUpper(enumType) + ")\n";
}

function funcWarning(str) {
  return str.replace(/\|\s\"[A-Z][A-Za-z0-9]+[\(]+[a-zA-Z0-9_]+[\)]+\"\s=>\s([A-Z][A-Za-z0-9]+)[\(]+([a-zA-Z0-9_]+)[\)]+/g, (function (param, first, second, param$1, param$2) {
                return "| \"" + first + "\" => get" + replaceFirstLetterUpper(second) + "() // Call you custom function here";
              }));
}

function getFunctionName(str) {
  return str.replace(/(\([a-zA-Z0-9_\",\s]+\))/g, "");
}

function typeFunctionMapper(str, type_) {
  switch (str) {
    case "Js.Json.t" :
        return "getJsonObjectFromDict(dict, \"" + type_ + "\")";
    case "array<float>" :
        return "getFloatArrayFromDict(dict, \"" + type_ + "\")";
    case "array<int>" :
        return "getIntArrayFromDict(dict, \"" + type_ + "\", [])";
    case "array<string>" :
        return "getStrArrayFromDict(dict, \"" + type_ + "\", [])";
    case "bool" :
        return "getBool(dict, \"" + type_ + "\", false)";
    case "float" :
        return "getFloat(dict, \"" + type_ + "\", 0.0)";
    case "int" :
        return "getInt(dict, \"" + type_ + "\", 0)";
    case "option<Js.Json.t>" :
        return "getOptionalJsonFromDict(dict, \"" + type_ + "\")";
    case "option<array<float>>" :
        return "getOptionFloatArrayFromDict(dict, \"" + type_ + "\")";
    case "option<array<int>>" :
        return "getOptionIntArrayFromDict(dict, \"" + type_ + "\")";
    case "option<array<string>>" :
        return "getOptionStrArrayFromDict(dict, \"" + type_ + "\")";
    case "option<bool>" :
        return "getOptionBool(dict, \"" + type_ + "\")";
    case "option<float>" :
        return "getOptionFloat(dict, \"" + type_ + "\")";
    case "option<int>" :
        return "getOptionInt(dict, \"" + type_ + "\")";
    case "option<string>" :
        return "getOptionString(dict, \"" + type_ + "\")";
    case "string" :
        return "getString(dict, \"" + type_ + "\", \"\")";
    default:
      return "||get" + replaceFirstLetterUpper(type_) + "(dict, \"" + type_ + "\")**" + str + "**||";
  }
}

function typeFunctionMapperEnum(str, type_) {
  switch (str) {
    case "Js.Json.t" :
        return "getJsonObjectFromDict(dict, \"" + type_ + "\")";
    case "array<float>" :
        return "getFloatArrayFromDict(dict, \"" + type_ + "\")";
    case "array<int>" :
        return "getIntArrayFromDict(dict, \"" + type_ + "\", [])";
    case "array<string>" :
        return "getStrArrayFromDict(dict, \"" + type_ + "\", [])";
    case "bool" :
        return "getBool(dict, \"" + type_ + "\", false)";
    case "float" :
        return "getFloat(dict, \"" + type_ + "\", 0.0)";
    case "int" :
        return "getInt(dict, \"" + type_ + "\", 0)";
    case "option<Js.Json.t>" :
        return "getOptionalJsonFromDict(dict, \"" + type_ + "\")";
    case "option<array<float>>" :
        return "getOptionFloatArrayFromDict(dict, \"" + type_ + "\")";
    case "option<array<int>>" :
        return "getOptionIntArrayFromDict(dict, \"" + type_ + "\")";
    case "option<array<string>>" :
        return "getOptionStrArrayFromDict(dict, \"" + type_ + "\")";
    case "option<bool>" :
        return "getOptionBool(dict, \"" + type_ + "\")";
    case "option<float>" :
        return "getOptionFloat(dict, \"" + type_ + "\")";
    case "option<int>" :
        return "getOptionInt(dict, \"" + type_ + "\")";
    case "option<string>" :
        return "getOptionString(dict, \"" + type_ + "\")";
    case "string" :
        return "getString(dict, \"" + type_ + "\", \"\")";
    default:
      return "||get" + replaceFirstLetterUpper(type_) + "Option(dict, \"" + type_ + "\")***" + str + "***||";
  }
}

function enumFunctionMapper(str) {
  console.log("enumFunctionMapper " + str + "");
  var regex = /^([a-zA-Z_]\w*)\(([a-zA-Z_]\w*)\)$/;
  var match$p = regex.exec(str);
  if (match$p !== null) {
    console.log("match");
    var enumName = Caml_array.get(match$p, 1);
    var enumType = Caml_array.get(match$p, 2);
    var enumDecode = typeFunctionMapperEnum(enumType, enumType);
    return "" + enumDecode + " -> Belt.Option.map(x => " + enumName + "(x))";
  }
  var caseBlock = "\t\t| \"" + str.trim() + "\" => Some(" + str + ")";
  return "  switch str {\n" + caseBlock + "\n\t\t| _ => None\n    }";
}

function getFuntionStr(fnName, type_, convertedBlock, kind) {
  var getKeyStr = "let " + fnName + " = (dict, key) => {\n  dict\n  ->Js.Dict.get(key)";
  var flatMapObjectDecodeStr = "->Belt.Option.flatMap(Js.Json.decodeObject)";
  if (/^option<([a-zA-Z0-9]+)>/.test(type_) && kind === /* Normal */1) {
    return "" + getKeyStr + "\n  " + flatMapObjectDecodeStr + "\n  ->Belt.Option.map(dict => {\n" + convertedBlock + "\n  })\n}\n";
  } else if (/^option<([a-zA-Z0-9]+)>/.test(type_) && kind === /* Varient */0) {
    return "" + getKeyStr + "\n  ->Belt.Option.flatMap(Js.Json.decodeString)\n  ->Belt.Option.map(str => {\n      \n" + convertedBlock + "\n  })\n}\n";
  } else if (/^array<([a-zA-Z0-9.]+)>/.test(type_)) {
    var optional = false;
    return "" + getKeyStr + "\n   ->Belt.Option.flatMap(Js.Json.decodeArray)\n   ->Belt.Option.getWithDefault([])\n   ->Belt.Array.keepMap(Js.Json.decodeObject)\n   ->Js.Array2.map(dict => {\n       " + convertedBlock + "\n   })" + (
            optional ? "->Some" : ""
          ) + "\n}\n";
  } else if (/^option<array<([a-zA-Z0-9]+)>>/.test(type_)) {
    return "let " + fnName + " = (dict, key) => {\n    switch dict->Js.Dict.get(key)->Belt.Option.flatMap(Js.Json.decodeArray) {\n  | Some(arr) =>\n    arr\n    " + flatMapObjectDecodeStr + "\n    ->Js.Array2.map(dict => {\n       " + convertedBlock + "\n    })\n    ->Some\n  | None => None\n   }\n}\n";
  } else if (kind === /* Normal */1) {
    return "" + getKeyStr + "\n  " + flatMapObjectDecodeStr + "\n  ->Belt.Option.map(dict => {\n     " + convertedBlock + "\n  })->Belt.Option.getWithDefault(default" + replaceFirstLetterUpper(type_) + ")\n}\n";
  } else {
    return "" + getKeyStr + "\n  ->Belt.Option.flatMap(Js.Json.decodeString)\n  ->Belt.Option.map(str => {\n      \n" + convertedBlock + "\n  })->Belt.Option.getWithDefault(default" + replaceFirstLetterUpper(type_) + ")\n}\n";
  }
}

function getFuntionStrEnum(fnName, type_, convertedBlock, kind) {
  var getKeyStr = "let " + fnName + " = (dict, _key) => {\n  Some(dict)";
  if (/^option<([a-zA-Z0-9]+)>/.test(type_) && kind === /* Normal */1) {
    return "" + getKeyStr + "\n  ->Belt.Option.map(dict => {\n" + convertedBlock + "\n  })\n}\n";
  } else if (/^option<([a-zA-Z0-9]+)>/.test(type_) && kind === /* Varient */0) {
    return "" + getKeyStr + "\n  ->Belt.Option.map(dict => {\n      \n" + convertedBlock + "\n  })\n}\n";
  } else if (/^array<([a-zA-Z0-9.]+)>/.test(type_)) {
    var optional = false;
    return "" + getKeyStr + "\n   ->Belt.Option.getWithDefault([])\n   ->Belt.Array.keepMap(Js.Json.decodeObject)\n   ->Js.Array2.map(dict => {\n      " + convertedBlock + "\n   })" + (
            optional ? "->Some" : ""
          ) + "\n}\n";
  } else if (/^option<array<([a-zA-Z0-9]+)>>/.test(type_)) {
    return "let " + fnName + " = (dict, key) => {\n    switch dict->Js.Dict.get(key)->Belt.Option.flatMap(Js.Json.decodeArray) {\n  | Some(arr) =>\n    arr\n    ->Belt.Option.flatMap(Js.Json.decodeObject)\n    ->Js.Array2.map(dict => {\n       " + convertedBlock + "\n    })\n    ->Some\n  | None => None\n   }\n}\n";
  } else if (kind === /* Normal */1) {
    return "" + getKeyStr + "\n  ->Belt.Option.map(dict => {\n     " + convertedBlock + "\n  })->Belt.Option.getWithDefault(default" + replaceFirstLetterUpper(type_) + ") -> returnNonDefault(default" + replaceFirstLetterUpper(type_) + ")\n}\n";
  } else {
    return "" + getKeyStr + "\n  ->Belt.Option.map(dict => {\n      \n" + convertedBlock + "\n  })->Belt.Option.getWithDefault(default" + replaceFirstLetterUpper(type_) + ") -> returnNonDefault(default" + replaceFirstLetterUpper(type_) + ")\n}\n";
  }
}

function getObjectFunction(mainStr, fnName, type_, allFiles) {
  var type_$1 = filterTypeName(type_);
  var fnName$1 = getFunctionName(fnName);
  var match = getRecordType(mainStr, type_$1, allFiles);
  var blockScopeTypes = match[1];
  var kind = match[0];
  var convertedBlock;
  if (kind) {
    convertedBlock = blockScopeTypes.replace(/([A-Za-z0-9_^]+)+\s*[:]\s+([a-zA-Z0-9_.<>]+)/g, (function (param, first, second, param$1, param$2) {
            var valueMapper = typeFunctionMapper(second, first);
            return "\t" + first + " : " + valueMapper + " ";
          }));
  } else {
    var caseBlock = blockScopeTypes.split("|").reduce((function (acc, item) {
            var item$1 = item.replace("\n", "").trim();
            return acc + (" -> Belt.Option.orElse(" + enumFunctionMapper(item$1) + ")");
          }), "") + "-> Belt.Option.getExn";
    convertedBlock = "  None\n      \n" + caseBlock + "";
  }
  return getFuntionStr(fnName$1, type_, convertedBlock, kind);
}

function getObjectFunctionEnum(mainStr, fnName, type_, allFiles) {
  var type_$1 = filterTypeName(type_);
  var match = getRecordType(mainStr, type_$1, allFiles);
  var blockScopeTypes = match[1];
  var kind = match[0];
  var convertedBlock;
  if (kind) {
    convertedBlock = blockScopeTypes.replace(/([A-Za-z0-9_^]+)+\s*[:]\s+([a-zA-Z0-9_.<>]+)/g, (function (param, first, second, param$1, param$2) {
            var valueMapper = typeFunctionMapperEnum(second, first);
            return "\t" + first + " : " + valueMapper + " ";
          }));
  } else {
    var caseBlock = blockScopeTypes.split("|").reduce((function (acc, item) {
            var item$1 = item.replace("\n", "").trim();
            return acc + (" -> Belt.Option.orElse(" + enumFunctionMapper(item$1) + ")");
          }), "") + " -> Belt.Option.getExn";
    convertedBlock = "  None\n      \n" + caseBlock + "";
  }
  var fnName$1 = getFunctionName(fnName);
  return getFuntionStrEnum(fnName$1, type_, convertedBlock, kind);
}

function generateNestedObject(str, mainStr, allfiles) {
  var someVal = {
    contents: str
  };
  var _str = str;
  while(true) {
    var str$1 = _str;
    var match = str$1.match(/\|\|(.*?)\*\*\*(.*?)\*\*\*\|\|/);
    if (match !== null) {
      var match$1 = Belt_Array.keepMap(match, (function (x) {
              return x;
            }));
      var defaultValue = getDefaultValue(mainStr, Caml_array.get(match$1, 2), allfiles);
      var nestedObject = getObjectFunctionEnum(mainStr, Caml_array.get(match$1, 1), Caml_array.get(match$1, 2), allfiles);
      someVal.contents = (defaultValue + "\n" + nestedObject + "\n" + someVal.contents).replace(Caml_array.get(match$1, 0), Caml_array.get(match$1, 1));
      _str = someVal.contents;
      continue ;
    }
    var match$2 = str$1.match(/\|\|(.*?)\*\*(.*?)\*\*\|\|/);
    if (match$2 === null) {
      return someVal.contents;
    }
    var match$3 = Belt_Array.keepMap(match$2, (function (x) {
            return x;
          }));
    var defaultValue$1 = getDefaultValue(mainStr, Caml_array.get(match$3, 2), allfiles);
    var nestedObject$1 = getObjectFunction(mainStr, Caml_array.get(match$3, 1), Caml_array.get(match$3, 2), allfiles);
    someVal.contents = (defaultValue$1 + "\n" + nestedObject$1 + "\n" + someVal.contents).replace(Caml_array.get(match$3, 0), Caml_array.get(match$3, 1));
    _str = someVal.contents;
    continue ;
  };
}

function generateDecode(type_, mainStr, allfiles) {
  var match = getRecordType(mainStr, type_, allfiles);
  var blockScopeTypes = match[1];
  var kind = match[0];
  var convertedBlock;
  if (kind) {
    convertedBlock = blockScopeTypes.replace(/(@as+[A-Za-z0-9_()^@\\\\\"]+)?\s+([A-Za-z0-9_\"\\^]+)+\s*[:]\s+([a-zA-Z0-9_.<>]+)/g, (function (param, first, second, third, param$1, param$2) {
            var first$1 = Belt_Option.getWithDefault(first, "").replace("\"", "").replace("\"", "").replace("(", "").replace(")", "").replace("@as", "");
            var second$1 = second.trim();
            var third$1 = third.trim();
            var valueMapper = typeFunctionMapper(third$1, first$1.length > 0 ? first$1 : second$1);
            return "\t" + second$1 + " : " + valueMapper + "\n";
          }));
  } else {
    var caseBlock = blockScopeTypes.split("|").reduce((function (acc, item) {
            var item$1 = item.replace("\n", "").trim();
            return acc + (" -> Belt.Option.orElse(" + enumFunctionMapper(item$1) + ")");
          }), "") + " -> Belt.Option.getExn";
    convertedBlock = "  None\n      \n" + caseBlock + "";
  }
  var mapper = kind ? "let itemToObjectMapper = dict => {\n" + convertedBlock + "\n}\n " : "let get" + replaceFirstLetterUpper(type_) + " = str => {\n" + convertedBlock + "\n}\n ";
  return generateNestedObject(mapper, mainStr, allfiles);
}

exports.replaceFirstLetterLower = replaceFirstLetterLower;
exports.replaceFirstLetterUpper = replaceFirstLetterUpper;
exports.getRecordType = getRecordType;
exports.defaultUserTypedValue = defaultUserTypedValue;
exports.defaultValueMapper = defaultValueMapper;
exports.filterTypeName = filterTypeName;
exports.getDefaultValue = getDefaultValue;
exports.funcWarning = funcWarning;
exports.getFunctionName = getFunctionName;
exports.typeFunctionMapper = typeFunctionMapper;
exports.typeFunctionMapperEnum = typeFunctionMapperEnum;
exports.enumFunctionMapper = enumFunctionMapper;
exports.getFuntionStr = getFuntionStr;
exports.getFuntionStrEnum = getFuntionStrEnum;
exports.getObjectFunction = getObjectFunction;
exports.getObjectFunctionEnum = getObjectFunctionEnum;
exports.generateNestedObject = generateNestedObject;
exports.generateDecode = generateDecode;
/* No side effect */
